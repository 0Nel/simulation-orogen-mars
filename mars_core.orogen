name 'simulation'

using_library "mars_interfaces", :typekit => false
using_library "mars_gui", :typekit => false
using_library "mars_app", :typekit => false
using_library "main_gui", :typekit => false
using_library "mars_sim", :typekit => false
using_library "lib_manager", :typekit => false
using_library "mars_graphics", :typekit => false
using_library "QtCore", :typekit => false
using_library "QtGui", :typekit => false

import_types_from "tasks/MarsControl.hpp"
import_types_from "servoTypes.hpp"

using_library "actuator_dispatcher"

# Core orogen module that brings up the mars simulation and
# makes it accessible as a orogen module
# use subclassing to derive robot specific modules, e.g.
#
# task_context 'RobotSimulation' do
#         subclasses 'simulation::Mars'
# end
#
# Pay attention that all these tasks have to be started within 
# one deployment to be able to share their static resources.
task_context "Mars" do
	needs_configuration

        operation("loadScene").
            argument("path","/std/string")

        property('add_floor',"/bool",false)

        property("show_coordinate_system","bool",false).
            dynamic

        property('initial_scene', '/std/string').
	    doc('the full path to the initial scene, this is needed because operations are not accessible during configuration within syskit (deadlock)')
	
        property('config_dir', '/std/string',"#{ENV['AUTOPROJ_PROJECT_BASE']}/install/configuration/mars_default").
	    doc('the full path to the main configuration folder')

        property('distributed_simulation', 'bool').
	    doc('switch to active the distributed simulation if needed')

        property('enable_gui', 'bool').
	    doc('start the simulation graphical interface with this module')

        property('controller_port', 'int').
            doc('set the controller port, e.g. 1600 for communication with monster')

        property('raw_options', '/std/vector<simulation::Option>').
            doc('forward the original mars arguments, such as -c 1600 for setting the ode port - option consists of name, here: -c and parameter: here 1600')

        # Add a task context
        # operation('addPlugin').
        #       returns('int').
        #       argument('taskcontext', '/
        # method addPlugin(input: TaskContext ) return bool
        # method removePlugin(input: TaskContext) return bool

        input_port('control_action', '/simulation/Control')
        
        output_port('time', 'double')

        port_driven 'control_action'

        exception_states :PHYSICS_ERROR
end

task_context "MarsPlugin" do
    needs_configuration

    error_states "LOST_MARS_CONNECTION"
    
end

task_context "CameraPlugin" do
    subclasses "MarsPlugin"
    property('name', '/std/string').
	doc('name of the camera in the scene file')
end

task_context "MarsCamera" do
    subclasses "CameraPlugin"
    needs_configuration

    output_port 'frame', ro_ptr('base::samples::frame::Frame')
end

task_context "MarsDepthCamera" do
    subclasses "CameraPlugin"
    needs_configuration
    
    output_port 'distance_image', ro_ptr('base::samples::DistanceImage')
end

task_context "MarsHighResRangeFinder" do
    subclasses "MarsDepthCamera"
    needs_configuration
    
    property('left_limit', 'double', -Math::PI/4.0).
        doc('Left limit of the vertical opening angle in radians')
    property('right_limit', 'double', Math::PI/4.0).
        doc('Right limit of the vertical opening angle in radians')
    property('resolution_vertical', 'double', Math::PI/180.0).
        doc('Vertical angular resolution in radians')    
           
    property('upper_limit', 'double', Math::PI/4.0).
        doc('Upper limit of the horizontal opening angle in radians')
    property('lower_limit', 'double', -Math::PI/4.0).
        doc('Lower limit of the horizontal opening angle in radians')
    property('resolution_horizontal', 'double', Math::PI/180.0).
        doc('Vertical angular resolution in radians')    
        
    property('minimum_distance', 'double', 1.0).
        doc('Smaller distances (meter) are discarded')
    property('maximum_distance', 'double', 80.0).
        doc('Larger distances (meter) are discarded')   

    output_port('pointcloud', '/base/samples/Pointcloud').
        doc 'Created by using the distance image of the MarsDepthCamera'
end

# E.g. (ruby script): Two actuators 'rear_left' and 'rear_right'.
# actuator_names = ["rear_left", "rear_right"]
# actuator_indices = [1, 2]  <- Using a negative index to invert, using 0 to deactivate
# actuators = TaskContext.get 'mars_actuator'
# actuators.names = actuator_names
# actuators.dispatch("name_of_the_actuator_set", actuator_indices)  <- Has to be done before configure and start!
task_context "MarsActuator" do
    subclasses "MarsPlugin"
    
    operation('dispatch').
        doc('creates an output port of actuator status and an input port for setting actuator commands').
        returns("bool").
        argument('name', 'std::string', "the name of the board set. Ports called status_name and cmd_name will be created").
        argument('actuatorMap', '/std/vector</int>', "A map that maps the actuator id to the position in the Command structure. Note that a negative value can be given to autoamtically invert the commands")

    dynamic_input_port(/cmd_\w+/, "base/actuators/Command").
        doc "commands for a set of actuators set up by #dispatch"
    dynamic_output_port(/status_\w+/, "base/actuators/Status").
        doc "status of a set of actuators set up by #dispatch"
    
    property('names', 'std/vector</std/string>').
	doc('Array of names of the motor in the scene file. The names get mapped to motor ids starting from zero')

    port_driven
end

task_context "MarsServo" do
    subclasses "MarsPlugin"

    property("zero_offset", "double", 0.0).
        doc "offset between the servo zero and the mounting zero"
    property("mode", "/servo/MODE", :POSITION).
       doc("mode of the module, 0 is hold position, 1 is contious sweep")
    property("lower_sweep_angle", "double", 0).
        doc("lower bound of the sweep")
    property("upper_sweep_angle", "double", 0).
        doc("upper bound of the sweep")
    property("moving_speed", "double", 0).
        doc("turning speed in rad/sec")
    property("upper_frame", "std/string", "upper_servo").
	doc "The name of the frame, where the upper part (rotating) of the servo is mounted"
    property("lower_frame", "std/string", "lower_servo").
	doc "The name of the frame, where the lower part (fixed) of the servo is mounted"
    property("rotation_axis", "base/Vector3d").
	doc "rotational axis for the upper2lower transform."

    output_port('upper2lower', '/base/samples/RigidBodyState').
	doc "transformation between the lower and upper frame. The rotational axis of the servo is specified in rotation_axis."
    output_port('angle', 'double').
	doc "current tilt angle of the servo, in radians"

    input_port('cmd_angle', 'double').
	doc "wanted tilt angle of the servo, in radians"

    operation("set_angle").
        returns('bool').
        argument("angle", "double", "set the angle of the servo, in radians")
    
    needs_configuration

    property('name', '/std/string', 'servo_motor').
	doc('name of the motor in the scene file, which should be handled as a servo')

end

task_context "MarsJoint" do
    subclasses "MarsPlugin"

    property("zero_offset", "double", 0.0).
        doc "offset between the servo zero and the mounting zero"
    property("mode", "/servo/MODE", :POSITION).
       doc("mode of the module, 0 is hold position, 1 is contious sweep")
    property("lower_sweep_angle", "double", 0).
        doc("lower bound of the sweep")
    property("upper_sweep_angle", "double", 0).
        doc("upper bound of the sweep")
    property("moving_speed", "double", 0).
        doc("turning speed in rad/sec")
    property("upper_frame", "std/string", "upper_servo").
	doc "The name of the frame, where the upper part (rotating) of the servo is mounted"
    property("lower_frame", "std/string", "lower_servo").
	doc "The name of the frame, where the lower part (fixed) of the servo is mounted"
    property("rotation_axis", "base/Vector3d").
	doc "rotational axis for the upper2lower transform."

    output_port('upper2lower', '/base/samples/RigidBodyState').
	doc "transformation between the lower and upper frame. The rotational axis of the servo is specified in rotation_axis."
    output_port('angle', 'double').
	doc "current tilt angle of the servo, in radians"
    output_port('torque', 'double').
	doc "current tilt torque acting on the joint, in Nm"

    input_port('cmd_angle', 'double').
	doc "wanted tilt angle of the servo, in radians"

    operation("set_angle").
        returns('bool').
        argument("angle", "double", "set the angle of the servo, in radians")
    
    needs_configuration

    property('name', '/std/string', 'servo_motor').
	doc('name of the motor in the scene file, which should be handled as a servo')

end

task_context "MarsTrigger" do
    subclasses "MarsPlugin"

    property "do_step","bool",false
    doc("This components triggeres the mars simulation cycle if the update-hook is called, 
        this is useful if an sequence between componentes is needed, like it is possible with the
        trigger_component")
end

task_context "MarsLaserRangeFinder" do
    subclasses "MarsPlugin"

    needs_configuration
    
    property('remission_values',  'bool', 0).
        doc 'include remission values in output if set to true and available in the device'
    property('start_step',  'int', -1).
        doc 'the step at which to start acquisition'
    property('end_step',    'int', -1).
        doc 'the step at which to end acquisition'
    property('scan_skip',   'int', 0).
        doc 'how much acquisitions to ignore between two acquisitions to report'
    property('merge_count', 'int', 1).
        doc 'how much ranges measurement to merge into one single reported measurement'

    output_port('scans', 'base/samples/LaserScan').
        max_sizes('remission' => 2000, 'ranges' => 2000).
        doc "the laser scans themselves"
    property('name', '/std/string', 'laser_scanner').
	doc('name of the sensor in the scene file')
end

task_context "MarsIMU" do
    subclasses "MarsPlugin"
    
    property("imu_frame", "std/string", "imu").
	doc "The name of the imu frame."
    property("world_frame", "std/string", "world").
	doc "The name of the world frame."

    output_port('orientation_samples', '/base/samples/RigidBodyState').
        doc 'provides timestamped IMUReading samples containing the orientation estimate as reported by the IMU.'
    output_port('calibrated_sensors', '/base/samples/IMUSensors').
        doc 'provides timestamped IMUReading samples containing the calibrated sensor readings.'
    
    needs_configuration
    
    property('name', '/std/string', 'imu').
	doc('name of the node in the scene file from which to get the imu data')

    output_port('pose_samples', '/base/samples/RigidBodyState').
        doc 'provides timestamped IMUReading samples containing the complete pose'
end

task_context "Actuators" do
    subclasses "MarsPlugin"
    needs_configuration
    
    property('node_name', 'std/string')
	doc 'the name of the vehicle in the scene file'
	
    property('amount_of_actuators', 'int')
	doc 'the amount of actuators the vehicle has'
	
    property('maximum_thruster_force', 'std/vector<double>')
	doc 'The maximum thruster foce for each actuator. Is also used as a factor. The size of the vector must equal to amount_of_actuators'
	
    property('thruster_position', 'std/vector</base/Vector3d>')
	doc 'Positions of the thrusters on the vehicle. The size of the vector must equal to amount_of_actuators'
	
    property('thruster_direction', 'std/vector</base/Vector3d>')
	doc 'Directions of the thruster force on the vehicle. The size of the vector must equal to amount_of_actuators'
	
    input_port("command", "base/actuators/Command").
        doc("actuator command").
        needs_buffered_connection
    output_port("status", "base/actuators/Status")
    port_driven :command
end

task_context "Sonar" do
    subclasses "MarsPlugin"
    needs_configuration
    
    property('node_name', 'std/string').
	doc 'the name of the vehicle in the scene file'
        
    property("left_limit","double").dynamic.
	doc 'maximum left angle'
    property("right_limit","double").dynamic.
	doc 'maximum right angle'
    property("resolution","double").dynamic.
	doc 'resolution of the sonar beam'
    property("maximum_distance","double").dynamic.
	doc 'maximum distance of the sonar beam'
    property("ping_pong_mode","bool").dynamic.
        doc('if true ping pong mode is activated')
	    
	
    output_port("sonar_beam","base::samples::SonarBeam").
        doc('top sonar beam')
end
    
#
#deployment "simulation" do
#        sim = task('mars_simulation', 'simulation::Mars')
#        acc = task('mars_actuator', 'simulation::MarsActuator')
#        cam = task('mars_camera', 'simulation::MarsCamera')
#	add_default_logger
#end
#


deployment "simulation" do
	task('simulation', 'simulation::Mars')
	task('actuators', 'simulation::Actuators')
	add_default_logger
end
