name 'simulation'

using_library "mars_interfaces", :typekit => false
using_library "mars_gui", :typekit => false
using_library "mars_app", :typekit => false
using_library "main_gui", :typekit => false
using_library "mars_sim", :typekit => false
using_library "lib_manager", :typekit => false
using_library "mars_graphics", :typekit => false
using_library "QtCore", :typekit => false
using_library "QtGui", :typekit => false

import_types_from "tasks/MarsControl.hpp"

using_task_library "interfaces"

# Core orogen module that brings up the mars simulation and
# makes it accessible as a orogen module
# use subclassing to derive robot specific modules, e.g.
#
# task_context 'RobotSimulation' do
#         subclasses 'simulation::Mars'
# end
#
# Pay attention that all these tasks have to be started within 
# one deployment to be able to share their static resources.
task_context "Mars" do
	needs_configuration

        operation("loadScene").
            argument("path","/std/string")

        property('add_floor',"/bool",false)
	
        property('initial_scene', '/std/string').
	    doc('the full path to the initial scene, this is needed because operations are not accessible during configuration within syskit (deadlock)')
	
        property('config_dir', '/std/string',"#{ENV['AUTOPROJ_PROJECT_BASE']}/install/configuration/mars_default").
	    doc('the full path to the main configuration folder')

        property('distributed_simulation', 'bool').
	    doc('switch to active the distributed simulation if needed')

        property('enable_gui', 'bool').
	    doc('start the simulation graphical interface with this module')

        property('controller_port', 'int').
            doc('set the controller port, e.g. 1600 for communication with monster')

        property('raw_options', '/std/vector<simulation::Option>').
            doc('forward the original mars arguments, such as -c 1600 for setting the ode port - option consists of name, here: -c and parameter: here 1600')

        # Add a task context
        # operation('addPlugin').
        #       returns('int').
        #       argument('taskcontext', '/
        # method addPlugin(input: TaskContext ) return bool
        # method removePlugin(input: TaskContext) return bool

        input_port('control_action', '/simulation/Control')
        
        output_port('time', 'double')

        port_driven 'control_action'
end

task_context "MarsCamera" do
    needs_configuration

    property('name', '/std/string').
	doc('name of the camera in the scene file')

    output_port 'frame', ro_ptr('base::samples::frame::Frame')

    property('fps', 'int',10).
        doc 'frames per second'
end

task_context "MarsDepthCamera" do
    needs_configuration

    property('name', '/std/string').
	doc('name of the camera in the scene file')

    output_port 'distance_image', ro_ptr('base::samples::DistanceImage')

    property('fps', 'int',10).
        doc 'frames per second'
end

# E.g. (ruby script): Two actuators 'rear_left' and 'rear_right' with scene indices 1 and 9
# actuator_names = ["rear_left", "rear_right"]
# actuator_indices = [1, 9]  <- Using a negative index to invert, using 0 to deactivate
# actuators = TaskContext.get 'mars_actuator'
# actuators.names = actuator_names
# actuators.dispatch("name_of_the_actuator_set", actuator_indices)  <- Has to be done before configure and start!
task_context "MarsActuator" do
    subclasses "interfaces::Actuator"
    
    property('names', 'std/vector</std/string>').
	doc('Array of names of the motor in the scene file. The names get mapped to motor ids starting from zero')

    port_driven
end

task_context "MarsServo" do
    subclasses "interfaces::Servo"
    needs_configuration

    property('name', '/std/string', 'servo_motor').
	doc('name of the motor in the scene file, which should be handled as a servo')

end

task_context "MarsTrigger" do
    property "do_step","bool",false
    doc("This components triggeres the mars simulation cycle if the update-hook is called, 
        this is useful if an sequence between componentes is needed, like it is possible with the
        trigger_component")
end

task_context "MarsLaserRangeFinder" do
    subclasses "interfaces::LaserRangeFinder"
    needs_configuration
    
    property('name', '/std/string', 'laser_scanner').
	doc('name of the sensor in the scene file')
end

task_context "MarsIMU" do
    subclasses "interfaces::IMU"
    needs_configuration
    
    property('name', '/std/string', 'imu').
	doc('name of the node in the scene file from which to get the imu data')

    output_port('pose_samples', '/base/samples/RigidBodyState').
        doc 'provides timestamped IMUReading samples containing the complete pose'
end
    

deployment "simulation" do
        sim = task('mars_simulation', 'simulation::Mars')
        acc = task('mars_actuator', 'simulation::MarsActuator')
        cam = task('mars_camera', 'simulation::MarsCamera')
	add_default_logger
end



